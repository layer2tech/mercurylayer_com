<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title></title>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    
    <link rel="icon" type="image/png" href="/favicon.png">

    <style>
    :root {
        /* Primary theme color */
        --primary-color: #0a0543;
        /* Primary theme text color */
        --primary-text-color: #ffffff;
        /* Primary theme link color */
        --primary-link-color: #F9BB2D;
        /* Secondary color: the background body color */
        --secondary-color: #2b12bb;
        --secondary-text-color: #070000;
        /* Highlight text color of table of content */
        --toc-highlight-text-color: #d46e13;
         /* Highlight text color of table of content */
        --toc-highlight-text-color: #d46e13;
        --toc-background-color: rgb(245, 235, 235);
        --code-color: #f7ebeb;
        --code-background-color: rgb(11, 145, 186);
    }
</style>
    
    <link href="https://fonts.googleapis.com/css?family=Alfa+Slab+One&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Fira+Sans:400,500,600&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="/normalize.css">
    <link rel="stylesheet" href="https://www.mercurylayer.com/juice.css">
    
<link rel="stylesheet" href="https://www.mercurylayer.com/style.css"/>
<link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=DM Mono"/>

</head>

<body>
    
<header class="header">
  

<a href="https:&#x2F;&#x2F;www.mercurylayer.com&#x2F;">
    <div class="logo">
        Mercury Layer
    </div>
</a>

<nav>
    
    
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;t.me&#x2F;mercury_layer">Telegram</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;twitter.com&#x2F;mercurylayer">Twitter</a>
        
        <a class="nav-item subtitle-text" href="https:&#x2F;&#x2F;github.com&#x2F;commerceblock&#x2F;mercurylayer">Github</a>
        
    
</nav>

</header>


<div class = "hero" style="position: relative;">
    <section style="padding:10px; max-width: 500px; color:#fff;">
        <h1 class="text-center heading-text">
            Mercury Layer
        </h1>
        <h3 class="text-center title-text">
            Blind Schnorr signing service
        </h3>
    </section>
    <div>
        <video class="hero-video" style="border-radius: 100px; max-width: 80%;" muted playsInline autoPlay loop>
            <source
                src="mercury-loop-820px-q35.webm"
                type="video/webm"
            />
            <source
                src="mercury-loop-820px-q35.mp4"
                type="video/mp4"
            />
            <source
                src="mercury-loop-820px-q35.ogv"
                type="video/ogg"
            />
            Sorry, your browser doesn't support embedded videos.
        </video>
    </div>

    <div class="explore-more text"
        onclick="document.getElementById('features').scrollIntoView({behavior: 'smooth'})">
        Explore More ⇩
    </div>
</div>
<style>
    .hero section {
        padding: 0 5rem;
    }
    @media screen and (max-width: 768px) {
        .hero section {
            padding: 0 2rem;
        }

        .hero-video {
            display: none
        }
       
    }
</style>




    <main>
        
        
        
        
        
        <div class="toc">
            <div class="toc-sticky">
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.mercurylayer.com/#mercury-layer">Mercury Layer</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.mercurylayer.com/#overview"><small>- Overview</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.mercurylayer.com/#service"><small>- Mercury layer service</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.mercurylayer.com/#statechains"><small>- Statechain transfers</small></a>
                </div>
                
                
                
                <div class="toc-item">
                    <a class="subtext" href="https://www.mercurylayer.com/#mercury-layer-protocol">Mercury Layer Protocol</a>
                </div>
                
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.mercurylayer.com/#preliminaries"><small>- Preliminaries</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.mercurylayer.com/#initiation"><small>- Initiation</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.mercurylayer.com/#key-reassignment"><small>- Key Reassignment</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.mercurylayer.com/#orderly-closure"><small>- Orderly Closure</small></a>
                </div>
                
                <div class="toc-item-child">
                    <a class="subtext" href="https://www.mercurylayer.com/#backup-closure"><small>- Backup closure</small></a>
                </div>
                
                
                
            </div>
        </div>
        
        

        <div class="content text">
            
            <div id="features" class="heading-text">Overview</div>
            <h1 id="mercury-layer">Mercury Layer</h1>
<p>Mercury layer is an implementation of a system the uses a blind co-signing and key-update service to enable statechains on Bitcoin. The statechain protocol allows the transfer of ownership of Bitcoin unspent transaction outputs (UTXOs) that remain under the full custody of the owner at all times, while benefiting from instant and zero cost transactions. The ability to perform this transfer without requiring the confirmation (mining) of on-chain transactions has advantages in a variety of different applications. </p>
<h2 id="overview">Overview</h2>
<p>The Mercury layer system employs a service provider (the mercury layer blind <em>server</em>) that generates and updates key shares (or key fragments) on request in addition to a count of partial blinded signatures. By updating (‘cycling’) a key share and reporting the number of  partial blinded signatures generated for the share, the ownership of individual UTXOs can be transferred between counterparties instantly and at zero marginal cost in a secure and fully self-custodial way. The blind key-update server never has control or custody, and is never aware of the identity of any specific UTXO. </p>
<p>This system requires that all bitcoin transaction operations and statechain verification are performed entirely by client-side software. </p>
<p><br><br></p>
<p align="center">
<img src="fig1.png" align="middle" width="60" vspace="20">
</p>
<p align="center">
  Blind mercury server operations
</p>
<br><br>

<h2 id="service">Mercury layer service</h2>
<p>The mercury layer service generates a private key share <code>s1</code> on initialisation of a session. In order to initialise a session, a client must provide a valid <code>token_id</code> which controls access to the service (and is generated separately typically after payment of a fee).</p>
<p>The client initialises a session with an <code>auth_pubkey</code> which is used to authenticate all subsequent messages with the server. The server responds with the public elliptic curve point corresponding to the server private key share <code>s1</code>.</p>
<p>Once initialised, the server can then perform two operations using the key share upon request:</p>
<ol>
<li>Partial signature generation - the server uses the key share to compute a partial signature from a blinded challenge value provided by the client.</li>
<li>Key update - a blinded value is sent to the server and used to update the key share along with an new <code>auth_pubkey</code>. The previous key share is deleted securely by the server.</li>
</ol>
<p>The server does not ever receive any other information regarding the client state. </p>           
<h2 id="statechains">Statechain transfers</h2>
<p>Using the mercury service, clients can use the key share update rules applied by the server to securely transfer ownership of a Bitcoin UTXO to a new client while maintaining self-custody without requiring a blockchain transaction. </p>
<p>This is achieved by depositing an amount of bitcoin to an address which is formed in part from the server public key share, and then requesting partial signature from the server to either spend the coin or create ‘backup transactions’ to protect against server unavailability (i.e. unilateral on-chain exit). Transfers to new clients are secured by the server key update, enabling the UTXO deposit address to stay the same, while removing the ability of a previous owner to steal the funds. </p>
<p>This key update mechanism is additionally combined with a system of backup transactions which can be used to claim the value of the UTXO by the current owner in the case the SE does not cooperate or has disappeared. The backup transaction is created by the current owner and the SE at the point of transfer, paying to an address controlled by the new owner. To prevent a previous owner (i.e. not the current owner) from broadcasting their backup transaction and stealing the deposit, the nLocktime value of the transaction is set to a future specified block height. Each time the ownership of the UTXO is transferred, the nLocktime is decremented by a specified value, therefore enabling the current owner to claim the coin before any of the previous owners.</p>
<p>The decrementing timelock backup mechanism limits the number of transfers that can be made within the lock-out time. The user is responsible for submitting backup transactions to the Bitcoin network at the correct time, and applications can do this automatically.</p>
<p>The life-cycle of a coin in the statechain, key reassignment and closure is summarised as follows:</p>
<ol>
<li>The first owner initiates a statechain by paying an amount of bitcoin to an address where the corresponding public key is formed from both the first owner public key share and the server public key share. The first owner creates a timelocked backup transaction spending the statechain UTXO to an address fully controlled by the first owner which can be confirmed after the nLocktime block height in case the server stops cooperating.</li>
<li>The owner can verifiably transfer ownership of the UTXO to a new party (Owner 2) via a key update procedure that overwrites the private key share of server that invalidates the first owner private key and activates the new owner private key share. Additionally, the transfer incorporates the signing of a new backup transaction paying to an address controlled by the new owner which can be confirmed after a new nLocktime block height, which is reduced (by an accepted confirmation interval) from the previous owners backup transaction nLocktime.</li>
<li>This transfer can be repeated multiple times to new owners as required (up until the most recent recovery nLocktime reaches a lower limit determined by the current Bitcoin block height).</li>
<li>At any time the most recent owner can create and sign a transaction spending the UTXO to an address of the most recent owner's choice (i.e. closure of the statechain).</li>
    
<p>The Mercury layer server is <em>blind</em> - that is the server <em>does not</em> and <em>cannot</em> know anything that would enable it to identify any coin (UTXO). This prevents any censorship and storage of any identifying data in the server - the server itself is not aware of bitcoin, and does not perform any verifcation of transactions. </p>
<p>To achieve this the server cannot know or be able to derive in any way the following values:</p>
<ul>
<li>The TxID:vout of the statecoin UTXO</li>
<li>The address (i.e. public key) of the UTXO</li>
<li>Any signatures added to the bitcoin blockchain for the coin public key.</li>
</ul>
<h3 id="blind-two-party-schnorr-signatures">Blind two-party Schnorr signatures</h3>
<p>Mercury layer employs Schnorr signatures via Taproot addresses for statecoins. To enable a signature to be generated over a shared public key (by the two private key shares of the server and owner) a blinded variant of the Musig2 protocol is employed. In this variant, one of the co-signing parties (the server) does not learn of 1) The full shared public key or 2) The final signature generated. </p>
<h3 id="client-transaction-verification">Client transaction verification</h3>
<p>The server cannot verify what it signs, but can only state HOW MANY unique signatures it has generated for a specific shared key, and it will return this number when queried by a wallet. The wallet will then have to check that every single previous backup transaction signed has been correctly decremented, AND that the total number of value backup transactions it has verified matches the number of signatures the server has co-generated. This will then enable a receiving wallet to verify that no other valid transactions spending the statecoin output exist (given it trusts the server to return the correct number of signatures). </p>
<p>When it comes to closure, the server can no longer verify that any fee has been added to the closure transaction, and the wallet can just create any transaction it wants to end the chain. In this case, any fee collected by the SE must be done separately to the statecoin initialisation and closure transactions (and be required on initialisation, before the shared key is generated).</p>
<h3 id="keyshare-publication">Keyshare publication</h3>
<p>The server does not have access to the TxIDs of individual coins along with the user proof keys that it can publish. Instead, it takes each of the current public key shares for each coin in the system and publishes this list. This is then updated with each new coin or coin ownership change. This public key list is then commited to bitcoin via Mainstay for a proof-of-uniqueness. </p>
<p>To verify the uniqueness of the ownership of the shared public key, the current owner then derives the full shared public key from this commitment and their or key share (P = o1.(s1.G)) and verifies it against the coin. </p>
<h1 id="mercury-layer-protocol">Mercury Layer Protocol</h1>
<h2 id="preliminaries">Preliminaries</h2>
<p>The blind server and each owner are required to generate private keys securely. Owners are required to verify ownership of UTXOs (this can be achieved via a wallet interface, and requires connection to an Electrum server or fully verifying Bitcoin node). Elliptic curve points (public keys) are depicted as upper case letter, and private keys as lower case letters. Elliptic curve point multiplication (i.e. generation of public keys from private keys) is denoted using the <code>.</code> symbol. The generator point of the elliptic curve standard used (e.g. secp256k1) is denoted as <code>G</code>. All arithmetic operations on secret values (in Zp) are modulo the field the EC standard.</p>
<p>In addition, a public key encryption scheme is required for blinded private key information sent between parties. This should be compatible with the EC keys used for signatures, and ECIES is used. The notation for the use of ECIES operations is as follows: <code>Enc(m,K)</code> denotes the encryption of message <code>m</code> with public key <code>K = k.G</code> and <code>Dec(m,k)</code> denotes the decryption of message <code>m</code> using private key <code>k</code>.</p>
<p>All transactions are created and signed using segregated witness, which enables input transaction IDs to be determined before signing and prevents their malleability. </p>
<h2 id="initiation">Initiation</h2>
<p>An user wants to create a statecoin for a specific amount of BTC, and they request that the server initialize the process. To begin, the user must provide a valid <code>token_id</code> (UUID), which will be listed in the the server token database. This <code>token_id</code> is generated by the server on payment of a fee (via a separate lighning or bitcoin payment). </p>
<ol>
<li>The initiator (Owner 1) generates a private key: <code>o1</code> (the UTXO private key share).</li>
<li>Owner 1 then calculates the corresponding public key of the share <code>O1</code>: <code>O1 = o1.G</code></li>
<li>Owner 1 requests a key share from the server with a valid <code>token_id</code> and <code>auth_pubkey</code>. </li>
<li>The server then generates a private key: <code>s1</code> (the server private key share), calculates the corresponding public key and returns it to Owner 1: <code>S1 = s1.G</code> along with a <code>statechain_id</code> (UUID). The server then stores <code>s1</code> indexed with <code>statechain_id</code>. </li>
<li>Owner 1 then adds the public key they receive by their own public key to obtain the shared (aggregated) public key <code>P</code> (which corresponds to a shared private key of <code>p = o1 + s1</code>): <code>P = O1 + S1</code></li>
<li>Owner 1 creates and broadcasts a funding transaction (<code>Tx0</code>) to pay an amount <code>A</code> to the address corresponding to <code>P</code>. This defines the UTXO <code>TxID:vout</code> (the outpoint). </li>
<li>Owner 1 creates an unsigned <em>backup transaction</em> (<code>Tx1</code>) that pays the <code>P</code> output of <code>Tx0</code> to address of <code>O1</code>, and sets the <code>nLocktime</code> to the initial future block height <code>h0</code> (where <code>h0 = cheight + hinit</code>, <code>cheight</code> is the current Bitcoin block height and <code>hinit</code> is the initial locktime specified by the server).</li>
<li>Owner 1 cooperates with server to generate a valid signature on <code>Tx1</code></li>
</ol>
<h3 id="signature-generation">Signature generation</h3>
<p>To generate a signature on <code>Tx1</code>, the owner first computes the sighash <code>m1</code>. 
Owner 1 then generates a random ephemeral nonce <code>r2_1</code> and blinding nonce <code>b1</code> and computes <code>R2_1 = r2_1.G</code>
Owner 1 then requests a partial signature from the server which generates a random <code>r1_1</code> and computes <code>R1_1 = r1_1.G</code>. <code>R1_1</code> is returned to Owner 1. 
Owner 1 then computes <code>R_1 = R1_1 + r2_1.G + b1.P</code>, <code>e1 = SHA256(P||R_1||m1)</code> and <code>c1 = e1 + b1</code> and sends <code>c1</code> to the server. 
The server then computes <code>sig1_1 = r1_1 + c1.s1</code> and sends to Owner 1. 
Owner 1 computes <code>sig2_1 = r2_1 + c1.o1</code> and <code>sig_1 = sig1_1 + sig2_1</code>. The full signature <code>(sig_1,R_1)</code> is then added to <code>Tx1</code>. </p>
<ol start="10">
<li><code>Tx1</code> is verified and stored by Owner 1. </li>
<li>The server then adds the public key <code>S1</code> to the list of current public key shares and publishes. </li>
</ol>
<h2 id="key-reassignment">Key Reassignment</h2>
<p>Owner 1 wishes to transfer the value of the coin <code>A</code> to a new owner (Owner 2). The protocol then proceeds as follows:</p>
<h3 id="sender">Sender</h3>
<ol>
<li>The receiver (Owner 2) generates a statechain private key <code>o2</code>. They then compute the corresponding public key <code>O2 = o2.G</code>.</li>
<li><code>O2</code> then forms part of the Owner 2 'address' (concatenated with their new <code>auth_pubkey</code> and is communicated to Owner 1 (or published) in order for them to 'send' the ownership.</li>
<li>Owner 1 then creates a new unsigned backup transaction <code>Tx2</code> paying the output of <code>Tx0</code> to address of <code>O2</code>, and sets the <code>nLocktime</code> to <code>h0 - (n-1)*c</code> where <code>c</code> is the confirmation interval and <code>n</code> is the owner number (i.e. 2). </li>
<li>Owner 1 cooperates with server to generate a valid signature on <code>Tx2</code></li>
</ol>
<h3 id="signature-generation-1">Signature generation</h3>
<p>To generate a signature on <code>Tx2</code>, the owner first computes the sighash <code>m2</code>. 
Owner 1 then generates a random ephemeral nonce <code>r2_2</code> and blinding nonce <code>b2</code> and computes <code>R2_2 = r2_2.G</code>
Owner 1 then requests a partial signature from the server which generates a random <code>r1_2</code> and computes <code>R1_2 = r1_2.G</code>. <code>R1_2</code> is returned to Owner 1. 
Owner 1 then computes <code>R_2 = R1_2 + r2_2.G + b2.P</code>, <code>e2 = SHA256(P||R_1||m1)</code> and <code>c2 = e2 + b2</code> and sends <code>c2</code> to the server. 
The server then computes <code>sig1_2 = r1_2 + c2.s1</code> and sends to Owner 1. 
Owner 1 computes <code>sig2_2 = r2_2 + c2.o1</code> and <code>sig_2 = sig1_2 + sig2_2</code>. The full signature <code>(sig_2,R_2)</code> is then added to <code>Tx2</code>.</p>
<ol start="4">
<li>The server then generates a random key <code>x1</code> on request and returns it to Owner 1. </li>
<li>Owner 1 then computes <code>t1 = o1 + x1</code></li>
<li>Owner 1 then concatinates the <code>Tx0</code> outpoint with the Owner 2 public key (<code>O2</code>) and signs it with their key <code>o1</code> to generate <code>SC_sig_1</code>. </li>
<li>Owner 1 then creates a message containing four objects:
a. All previous signed backup transactions: <code>Tx1</code> and <code>Tx2</code>
b. <code>SC_sig_1</code>
c. <code>t2</code>
d. <code>statechain_id</code></li>
<li>This message is then encrypted with the receiver <code>auth_pubkey</code>: <code>Enc(message,auth_pubkey)</code> and sent to the receiver (can be relayed).</li>
</ol>
<blockquote>
<p>At this point the Owner 1 has sent all the information required to complete the reassignment to Owner 2 and is no longer involved in the protocol. Owner 2 then verifies the correctness and validity of the message. </p>
</blockquote>
<h3 id="receiver">Receiver</h3>
<ol>
<li>Owner 2 decrypts the transfer message with their auth key.</li>
<li>Owner 2 verifies that the latest backup transaction pays to <code>O2</code> and that the input (<code>Tx0</code>) is unspent and pays to <code>P</code>. </li>
<li>Owner 2 takes the list of previous <code>K</code> backup transactions (<code>Txi i=1,...,K</code>) and for each one <code>i</code> verifies:
a. The signature is valid. 
b. The <code>nLocktimes</code> are decremented correctly (i.e. the latest <code>TxK</code> is the lowest). </li>
<li>Owner 2 queries the server for 1) The total number of signatures generated for <code>statechain_id</code>: <code>N</code> and 2) Current server public key share: <code>S1</code>. </li>
<li>Owner 2 then verifies that <code>K = N</code> and then <code>O1 + S1 = P</code></li>
</ol>
<p>The server key share update then proceeds as follows:</p>
<ol start="5">
<li>Owner 2 computes <code>t2 = t1 - o2</code>. </li>
<li>Owner 2 then sends <code>t2</code> to the server </li>
<li>The server updates the private key share <code>s2 = s1 + t2 - x1 = s1 + x1 + o1 - o2 - x1 = s1 + o1 - o2</code></li>
</ol>
<blockquote>
<p><code>s2</code> and <code>o2</code> are now key the private key shares of <code>P = (s2 + o2).G</code> which remains unchanged (i.e. <code>s2 + o2 = s1 + o1</code>), without anyone having learnt the full private key. Provided the server deletes <code>s1</code>, then there is no way anyone but the current owner (with <code>o2</code>) can spend the output.</p>
</blockquote>
<ol start="8">
<li>The server then adds the public key <code>S2</code> to the list of active key shares and publishes. </li>
</ol>
<h2 id="orderly-closure">Orderly Closure</h2>
<p>The current owner of a UTXO can at any time spend the statecoin by simply co-signing a transaction paying to any specified address. The server cannot identify a closure, but the coin can no longer be transferred to a new owner because the server will have produced an additional signature that cannot be verified as a valid backup by a receiver. </p>
<p>Closure proceeds as follows:</p>
<ol>
<li>The current owner (e.g. Owner 2) creates an unsigned transaction <code>TxW</code> that spends <code>Tx0</code> to a closure address <code>W</code>.</li>
<li>The owner then co-signs this transaction with the server (as above).  <code>TxW</code> is broadcast. </li>
<li>The owner then sends the server a closure notification (with their current <code>statechain_id</code>) that the coin is withdrawn so the server can remove the coin public from the published key share list. </li>
</ol>
<h2 id="backup-closure">Backup closure</h2>
<p>In the case that the server disappears or does not cooperate with the current owner, the current owner can reclaim their funds to an address they control by submitting their backup transaction when the <code>nLocktime</code> is reached. </p>

            
        </div>

        
        
    </main>

    
<footer>
    <small class="subtext" style="float;">
      @ <script>
        const currentYear = new Date().getFullYear();
        document.write(currentYear);
      </script> Mercury Layer Team
    </small>
    <a href="/privacy/">Privacy Policy</a>
  </footer>

</body>
<script>
    const scrollHandler = entries => {
        // Find the first entry which intersecting and ratio > 0.9 to highlight.
        let entry = entries.find(entry => {
            return entry.isIntersecting && entry.intersectionRatio > 0.9;
        });
        if (!entry) return;

        document.querySelectorAll(".toc a").forEach((item) => {
            item.classList.remove("active");
        });

        // let url = new URL(`#${entry.target.id}`);
        let link = document.querySelector(`.toc a[href$="${decodeURIComponent(`#${entry.target.id}`)}"]`)
        if (link) {
            link.classList.add("active");
            link.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
    };
    // Set -100px root margin to improve highlight experience.
    const observer = new IntersectionObserver(scrollHandler, { threshold: 1 });
    let items = document.querySelectorAll('h1,h2,h3,h4,h5,h6');
    items.forEach(item => observer.observe(item));
</script>

</html>
